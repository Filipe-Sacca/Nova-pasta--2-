import axios from 'axios';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

interface Product {
  item_id: string;
  name: string;
  category: string | null;
  description: string | null;
  merchant_id: string;
  is_active: string;
  price: number | null;
  imagePath: string | null;
  product_id: string;
  client_id?: string;  // client_id √© opcional pois vamos buscar do merchant
}

interface ApiProduct {
  id: string;
  name: string;
  description: string;
  status: string;
  productId: string;
  imagePath: string;
  price: {
    value: number;
  };
  categoryName?: string;  // Adicionado pela nossa l√≥gica
}

interface ServiceResponse {
  success: boolean;
  data?: any;
  error?: string;
  total_products?: number;
  new_products?: number;
  updated_products?: number;
}

interface CreateCategoryRequest {
  id: string;
  name: string;
  externalCode: string;
  status: 'AVAILABLE' | 'UNAVAILABLE';
  index: number;
  template: 'DEFAULT' | 'PIZZA' | 'COMBO';
}

interface CreateCategoryResponse {
  success: boolean;
  data?: {
    categoryId: string;
    merchantId: string;
    catalogId: string;
    name?: string;
  };
  error?: string;
}

export class IFoodProductService {
  private supabase: SupabaseClient;
  private readonly IFOOD_API_BASE_URL = 'https://merchant-api.ifood.com.br';

  constructor(supabaseUrl: string, supabaseKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
  }

  /**
   * Sincronizar produtos seguindo o fluxo especificado:
   * 1. Buscar token no banco
   * 2. Buscar merchant_id no banco
   * 3. Buscar catalog_id da API do iFood
   * 4. Buscar produtos da API do iFood
   * 5. Salvar produtos no banco
   */
  async syncProducts(userId: string, accessToken?: string): Promise<ServiceResponse> {
    try {
      console.log(`üõçÔ∏è [PRODUCT SYNC] Iniciando sincroniza√ß√£o de produtos para usu√°rio: ${userId}`);

      // 1. Buscar token de acesso no banco de dados
      let token = accessToken;
      if (!token) {
        console.log('üîç [STEP 1] Buscando token de acesso no banco de dados...');
        console.log('üîç [TOKEN QUERY] user_id procurado:', userId);
        
        const { data: tokenData, error: tokenError } = await this.supabase
          .from('ifood_tokens')
          .select('access_token, client_id, created_at, token_updated_at')
          .eq('user_id', userId)
          .single();

        console.log('üìä [TOKEN RESULT] Token encontrado:', !!tokenData);
        console.log('üìä [TOKEN RESULT] Client ID:', tokenData?.client_id || 'N/A');
        console.log('‚ùå [TOKEN ERROR] Erro:', tokenError?.message || 'Nenhum');
        
        if (tokenError || !tokenData?.access_token) {
          console.error('‚ùå [TOKEN FAILURE] Token n√£o encontrado para user_id:', userId);
          console.error('‚ùå [TOKEN FAILURE] Erro detalhado:', tokenError);
          return {
            success: false,
            error: 'Token de acesso n√£o encontrado. Fa√ßa login no iFood primeiro.'
          };
        }

        token = tokenData.access_token;
        console.log('‚úÖ [TOKEN SUCCESS] Token obtido, tamanho:', token?.length || 0);
        console.log('‚úÖ [STEP 1] Token encontrado no banco de dados');
      }

      // 2. Buscar merchant_id no banco de dados
      console.log('üîç [STEP 2] Buscando merchants no banco de dados...');
      const { data: merchants, error: merchantsError } = await this.supabase
        .from('ifood_merchants')
        .select('merchant_id, name, client_id')
        .eq('user_id', userId);

      if (merchantsError || !merchants || merchants.length === 0) {
        return {
          success: false,
          error: 'Nenhum merchant encontrado. Sincronize as lojas primeiro.'
        };
      }

      console.log(`‚úÖ [STEP 2] ${merchants.length} merchants encontrados no banco`);

      let totalProducts = 0;
      let newProducts = 0;
      let updatedProducts = 0;

      // Processar cada merchant
      for (const merchant of merchants) {
        try {
          console.log(`üîÑ [PROCESSING] Merchant: ${merchant.name} (${merchant.merchant_id})`);
          
          const result = await this.processMerchantProducts(
            merchant.merchant_id, 
            merchant.client_id,
            token!
          );

          totalProducts += result.total || 0;
          newProducts += result.new || 0;
          updatedProducts += result.updated || 0;

        } catch (error) {
          console.error(`‚ùå [ERROR] Merchant ${merchant.merchant_id}:`, error);
          continue;
        }
      }

      console.log(`‚úÖ [PRODUCT SYNC] Sincroniza√ß√£o conclu√≠da:`, {
        totalProducts,
        newProducts,
        updatedProducts
      });

      return {
        success: true,
        data: {
          merchants_processed: merchants.length,
          total_products: totalProducts,
          new_products: newProducts,
          updated_products: updatedProducts
        },
        total_products: totalProducts,
        new_products: newProducts,
        updated_products: updatedProducts
      };

    } catch (error: any) {
      console.error('‚ùå [PRODUCT SYNC] Erro geral na sincroniza√ß√£o:', error);
      return {
        success: false,
        error: error.message || 'Erro interno ao sincronizar produtos'
      };
    }
  }

  /**
   * Processar produtos de um merchant espec√≠fico seguindo o fluxo:
   * 3. Buscar catalog_id da API do iFood v2.0
   * 4. Buscar categorias e produtos da API do iFood v2.0
   * 5. Salvar produtos no banco
   */
  private async processMerchantProducts(merchantId: string, clientId: string, accessToken: string): Promise<{
    total: number;
    new: number;
    updated: number;
  }> {
    try {
      // 3. Buscar catalog_id da API do iFood v2.0
      console.log(`üîç [STEP 3] Buscando cat√°logos do merchant ${merchantId} (v2.0)...`);
      const catalogsUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs`;
      
      let catalogId: string;
      
      try {
        const catalogsResponse = await axios.get(catalogsUrl, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/json'
          }
        });

        const catalogsData = catalogsResponse.data;
        
        // A API retorna um array de cat√°logos
        if (!catalogsData || !Array.isArray(catalogsData) || catalogsData.length === 0) {
          console.log(`üì≠ [STEP 3] Nenhum cat√°logo encontrado para merchant ${merchantId}`);
          return { total: 0, new: 0, updated: 0 };
        }
        
        // Pegar o primeiro cat√°logo dispon√≠vel (geralmente o principal)
        const catalog = catalogsData[0];
        catalogId = catalog.catalogId || catalog.id;
        console.log(`‚úÖ [STEP 3] Cat√°logo encontrado: ${catalogId} de ${catalogsData.length} cat√°logo(s) dispon√≠vel(is)`);
        
      } catch (error: any) {
        console.error(`‚ùå [STEP 3] Erro ao buscar cat√°logo v2.0:`, error.response?.data || error.message);
        return { total: 0, new: 0, updated: 0 };
      }

      let allProducts: ApiProduct[] = [];

      // 4. Buscar produtos da API do iFood v2.0 usando o catalogId obtido
      try {
        console.log(`üîç [STEP 4] Buscando categorias e produtos do cat√°logo ${catalogId} (v2.0)...`);
        
        const productsUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs/${catalogId}/categories?includeItems=true&include_items=true`;
        
        const productsResponse = await axios.get(productsUrl, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/json'
          }
        });

        const categoriesData = productsResponse.data;
        
        // Extrair produtos de todas as categorias
        if (categoriesData && Array.isArray(categoriesData)) {
          for (const category of categoriesData) {
            if (category.items && category.items.length > 0) {
              // Adicionar categoria a cada produto
              const productsWithCategory = category.items.map((item: any) => ({
                ...item,
                categoryName: category.name || 'Sem categoria'
              }));
              allProducts = allProducts.concat(productsWithCategory);
              console.log(`  üì¶ Categoria "${category.name || 'Sem nome'}": ${category.items.length} produtos`);
            }
          }
        }

        console.log(`‚úÖ [STEP 4] Total de produtos encontrados: ${allProducts.length}`);

      } catch (error: any) {
        console.error(`‚ùå [STEP 4] Erro ao buscar produtos do cat√°logo ${catalogId}:`, error.response?.data || error.message);
        return { total: 0, new: 0, updated: 0 };
      }

      if (allProducts.length === 0) {
        console.log(`üì≠ [STEP 4] Nenhum produto encontrado para merchant ${merchantId}`);
        return { total: 0, new: 0, updated: 0 };
      }

      console.log(`üì¶ [STEP 4] Total de produtos encontrados: ${allProducts.length}`);

      // 5. Salvar produtos no banco de dados
      console.log(`üíæ [STEP 5] Salvando produtos no banco de dados...`);
      let newCount = 0;
      let updatedCount = 0;

      for (const apiProduct of allProducts) {
        try {
          const product: Product = {
            item_id: apiProduct.id,
            name: apiProduct.name,
            category: apiProduct.categoryName || null,
            description: apiProduct.description || null,
            merchant_id: merchantId,
            is_active: apiProduct.status,
            price: apiProduct.price?.value || null,
            imagePath: apiProduct.imagePath || null,
            product_id: apiProduct.productId || apiProduct.id,
            client_id: clientId
          };

          // Verificar se produto j√° existe
          const { data: existingProduct } = await this.supabase
            .from('products')
            .select('id, is_active, price, name')
            .eq('item_id', product.item_id)
            .eq('merchant_id', merchantId)
            .single();

          if (existingProduct) {
            // Atualizar se houver mudan√ßas
            if (existingProduct.is_active !== product.is_active || 
                existingProduct.price !== product.price ||
                existingProduct.name !== product.name) {
              
              await this.supabase
                .from('products')
                .update({
                  is_active: product.is_active,
                  price: product.price,
                  name: product.name,
                  description: product.description,
                  imagePath: product.imagePath,
                  updated_at: new Date().toISOString()
                })
                .eq('item_id', product.item_id)
                .eq('merchant_id', merchantId);

              updatedCount++;
              console.log(`üîÑ [STEP 5] Produto atualizado: ${product.name}`);
            }
          } else {
            // Criar novo produto
            const { error: insertError } = await this.supabase
              .from('products')
              .insert(product);

            if (insertError) {
              console.error(`‚ùå [STEP 5] Erro ao inserir produto ${product.name}:`, insertError);
            } else {
              newCount++;
              console.log(`‚ûï [STEP 5] Novo produto adicionado: ${product.name}`);
            }
          }

        } catch (error) {
          console.error(`‚ùå [STEP 5] Erro ao processar produto ${apiProduct.id}:`, error);
          continue;
        }
      }

      console.log(`‚úÖ [STEP 5] Produtos salvos: ${newCount} novos, ${updatedCount} atualizados`);

      return {
        total: allProducts.length,
        new: newCount,
        updated: updatedCount
      };

    } catch (error: any) {
      console.error(`‚ùå [ERROR] Erro ao processar produtos do merchant ${merchantId}:`, error);
      throw error;
    }
  }

  /**
   * Criar uma nova categoria no cat√°logo do iFood
   * Endpoint: POST /catalog/v2.0/merchants/{merchantId}/catalogs/{catalogId}/categories
   */
  async createCategory(userId: string, merchantId: string, categoryData: Omit<CreateCategoryRequest, 'id'>, accessToken?: string): Promise<CreateCategoryResponse> {
    try {
      console.log(`üè™ [CREATE CATEGORY] Iniciando cria√ß√£o de categoria para merchant: ${merchantId}`);
      console.log(`üìù [CREATE CATEGORY] Dados da categoria:`, categoryData);

      // 1. Usar token fornecido ou buscar no banco
      let token = accessToken;
      
      if (!token) {
        console.log('üîç [STEP 1] Buscando token de acesso no banco...');
        const { data: tokenData, error: tokenError } = await this.supabase
          .from('ifood_tokens')
          .select('access_token')
          .eq('user_id', userId)
          .single();

        if (tokenError || !tokenData?.access_token) {
          console.error('‚ùå [TOKEN FAILURE] Token n√£o encontrado para user_id:', userId);
          return {
            success: false,
            error: 'Token de acesso n√£o encontrado. Fa√ßa login no iFood primeiro.'
          };
        }

        token = tokenData.access_token;
        console.log('‚úÖ [STEP 1] Token obtido do banco com sucesso');
      } else {
        console.log('‚úÖ [STEP 1] Usando token fornecido via par√¢metro');
      }

      // 2. Buscar catalog_id via API do iFood
      console.log('üîç [STEP 2] Buscando catalog_id do merchant...');
      const catalogsUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs`;
      
      let catalogId: string;
      try {
        const catalogsResponse = await axios.get(catalogsUrl, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/json'
          }
        });

        const catalogsData = catalogsResponse.data;
        if (!catalogsData || !Array.isArray(catalogsData) || catalogsData.length === 0) {
          return {
            success: false,
            error: 'Nenhum cat√°logo encontrado para este merchant'
          };
        }

        catalogId = catalogsData[0].catalogId || catalogsData[0].id;
        console.log(`‚úÖ [STEP 2] Catalog ID encontrado: ${catalogId}`);
        
      } catch (error: any) {
        console.error('‚ùå [STEP 2] Erro ao buscar cat√°logo:', error.response?.data || error.message);
        return {
          success: false,
          error: 'Erro ao buscar cat√°logo do merchant'
        };
      }

      // 3. Criar categoria usando merchantId como ID da categoria
      console.log('üì¶ [STEP 3] Criando categoria no iFood...');
      const createCategoryUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs/${catalogId}/categories`;
      
      // Gerar ID √∫nico para a categoria
      const categoryId = `cat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Criar body com formato correto para a API do iFood
      const requestBody: any = {
        name: categoryData.name,
        status: categoryData.status, // iFood usa AVAILABLE/UNAVAILABLE
        index: categoryData.index,
        template: categoryData.template === 'PIZZA' ? 'PIZZA' : 'DEFAULT' // Apenas DEFAULT ou PIZZA
      };
      
      // Adicionar campos opcionais apenas se fornecidos
      if (categoryData.externalCode) {
        requestBody.externalCode = categoryData.externalCode;
      }

      console.log('üåê [API REQUEST] URL:', createCategoryUrl);
      console.log('üì§ [API REQUEST] Body:', requestBody);

      try {
        const createResponse = await axios.post(createCategoryUrl, requestBody, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/json',
            'Content-Type': 'application/json'
          }
        });

        console.log('‚úÖ [STEP 3] Categoria criada com sucesso');
        console.log('üì• [API RESPONSE] Status:', createResponse.status);
        console.log('üì• [API RESPONSE] Data:', createResponse.data);

        // 4. Salvar categoria local para refer√™ncia futura (opcional)
        try {
          await this.supabase
            .from('ifood_categories')
            .insert({
              category_id: categoryId,
              ifood_category_id: createResponse.data.id, // ID retornado pela API do iFood
              merchant_id: merchantId,
              catalog_id: catalogId,
              name: requestBody.name,
              external_code: requestBody.externalCode,
              status: requestBody.status,
              index: requestBody.index,
              template: requestBody.template,
              sequence_number: createResponse.data.sequence || createResponse.data.index || requestBody.index,
              user_id: userId,
              created_at: new Date().toISOString()
            });

          console.log('üíæ [STEP 4] Categoria salva localmente com ID do iFood:', createResponse.data.id);
        } catch (localError) {
          console.warn('‚ö†Ô∏è [STEP 4] Erro ao salvar categoria localmente:', localError);
          // N√£o falhar por erro local
        }

        return {
          success: true,
          data: {
            categoryId: categoryId,
            merchantId: merchantId,
            catalogId: catalogId,
            name: categoryData.name
          }
        };

      } catch (error: any) {
        console.error('‚ùå [STEP 3] Erro ao criar categoria:', error.response?.data || error.message);
        console.error('‚ùå [STEP 3] Detalhes completos do erro:', JSON.stringify(error.response?.data, null, 2));
        return {
          success: false,
          error: error.response?.data?.message || error.message || 'Erro ao criar categoria no iFood'
        };
      }

    } catch (error: any) {
      console.error('‚ùå [CREATE CATEGORY] Erro geral:', error);
      return {
        success: false,
        error: error.message || 'Erro interno ao criar categoria'
      };
    }
  }

  /**
   * Sincronizar todas as categorias do iFood para o banco de dados
   * Busca categorias existentes na API e salva localmente
   */
  async syncCategories(userId: string, merchantId: string, accessToken?: string): Promise<{success: boolean; data?: any; error?: string}> {
    try {
      console.log(`üìÇ [SYNC CATEGORIES] Iniciando sincroniza√ß√£o de categorias para merchant: ${merchantId}`);

      // 1. Usar token fornecido ou buscar no banco
      let token = accessToken;
      if (!token) {
        console.log('üîç [STEP 1] Buscando token de acesso no banco...');
        const { data: tokenData, error: tokenError } = await this.supabase
          .from('ifood_tokens')
          .select('access_token')
          .eq('user_id', userId)
          .single();

        if (tokenError || !tokenData?.access_token) {
          console.error('‚ùå [TOKEN FAILURE] Token n√£o encontrado para user_id:', userId);
          return {
            success: false,
            error: 'Token de acesso n√£o encontrado. Fa√ßa login no iFood primeiro.'
          };
        }
        token = tokenData.access_token;
        console.log('‚úÖ [STEP 1] Token obtido do banco com sucesso');
      }

      // 2. Buscar catalog_id via API do iFood
      console.log('üîç [STEP 2] Buscando catalog_id do merchant...');
      const catalogsUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs`;
      
      let catalogId: string;
      try {
        const catalogsResponse = await axios.get(catalogsUrl, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/json'
          }
        });

        const catalogsData = catalogsResponse.data;
        if (!catalogsData || !Array.isArray(catalogsData) || catalogsData.length === 0) {
          return {
            success: false,
            error: 'Nenhum cat√°logo encontrado para este merchant'
          };
        }

        catalogId = catalogsData[0].catalogId || catalogsData[0].id;
        console.log(`‚úÖ [STEP 2] Catalog ID encontrado: ${catalogId}`);
      } catch (error: any) {
        console.error('‚ùå [STEP 2] Erro ao buscar cat√°logo:', error.response?.data || error.message);
        return {
          success: false,
          error: 'Erro ao buscar cat√°logo do merchant'
        };
      }

      // 3. Buscar TODAS as categorias da API do iFood
      console.log('üìÇ [STEP 3] Buscando todas as categorias do cat√°logo...');
      const categoriesUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs/${catalogId}/categories`;
      
      let allCategories: any[] = [];
      try {
        const categoriesResponse = await axios.get(categoriesUrl, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/json'
          }
        });

        allCategories = categoriesResponse.data || [];
        console.log(`‚úÖ [STEP 3] ${allCategories.length} categorias encontradas na API do iFood`);
      } catch (error: any) {
        console.error('‚ùå [STEP 3] Erro ao buscar categorias:', error.response?.data || error.message);
        return {
          success: false,
          error: 'Erro ao buscar categorias da API do iFood'
        };
      }

      // 4. Sincronizar categorias no banco de dados
      console.log('üíæ [STEP 4] Sincronizando categorias no banco de dados...');
      let newCount = 0;
      let updatedCount = 0;
      let skippedCount = 0;

      for (const apiCategory of allCategories) {
        try {
          // Verificar se categoria j√° existe no banco
          const { data: existingCategory } = await this.supabase
            .from('ifood_categories')
            .select('id, name, status')
            .eq('ifood_category_id', apiCategory.id)
            .eq('merchant_id', merchantId)
            .single();

          if (existingCategory) {
            // Atualizar categoria existente se houver mudan√ßas
            if (existingCategory.name !== apiCategory.name || existingCategory.status !== apiCategory.status) {
              await this.supabase
                .from('ifood_categories')
                .update({
                  name: apiCategory.name,
                  status: apiCategory.status,
                  index: apiCategory.index || 0,
                  template: apiCategory.template || 'DEFAULT',
                  sequence_number: apiCategory.sequence || apiCategory.index || 0,
                  external_code: apiCategory.externalCode,
                  updated_at: new Date().toISOString()
                })
                .eq('ifood_category_id', apiCategory.id)
                .eq('merchant_id', merchantId);

              updatedCount++;
              console.log(`üîÑ [STEP 4] Categoria atualizada: ${apiCategory.name}`);
            } else {
              skippedCount++;
              console.log(`‚è≠Ô∏è [STEP 4] Categoria inalterada: ${apiCategory.name}`);
            }
          } else {
            // Criar nova categoria no banco
            const categoryId = `cat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            await this.supabase
              .from('ifood_categories')
              .insert({
                category_id: categoryId,
                ifood_category_id: apiCategory.id,
                merchant_id: merchantId,
                catalog_id: catalogId,
                name: apiCategory.name,
                external_code: apiCategory.externalCode,
                status: apiCategory.status || 'AVAILABLE',
                index: apiCategory.index || 0,
                template: apiCategory.template || 'DEFAULT',
                sequence_number: apiCategory.sequence || apiCategory.index || 0,
                user_id: userId,
                created_at: new Date().toISOString()
              });

            newCount++;
            console.log(`‚ûï [STEP 4] Nova categoria adicionada: ${apiCategory.name}`);
          }
        } catch (error: any) {
          console.error(`‚ùå [STEP 4] Erro ao processar categoria ${apiCategory.name}:`, error);
          continue;
        }
      }

      console.log(`‚úÖ [SYNC CATEGORIES] Sincroniza√ß√£o conclu√≠da:`);
      console.log(`  üìä Total na API: ${allCategories.length}`);
      console.log(`  ‚ûï Novas: ${newCount}`);
      console.log(`  üîÑ Atualizadas: ${updatedCount}`);
      console.log(`  ‚è≠Ô∏è Inalteradas: ${skippedCount}`);

      return {
        success: true,
        data: {
          total: allCategories.length,
          new: newCount,
          updated: updatedCount,
          skipped: skippedCount,
          merchant_id: merchantId,
          catalog_id: catalogId
        }
      };

    } catch (error: any) {
      console.error('‚ùå [SYNC CATEGORIES] Erro geral:', error);
      return {
        success: false,
        error: error.message || 'Erro interno ao sincronizar categorias'
      };
    }
  }

  /**
   * Buscar itens do cat√°logo do iFood
   * GET /catalog/v2.0/merchants/{merchantId}/catalogs/{catalogId}/items
   */
  async getItemsFromIfood(userId: string, merchantId: string, categoryId?: string): Promise<ServiceResponse> {
    try {
      console.log(`üì¶ [GET ITEMS] Buscando itens do iFood para merchant: ${merchantId}`);

      // 1. Buscar token
      const { data: tokenData, error: tokenError } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('client_id', userId)  // Using client_id instead of user_id
        .single();

      if (tokenError || !tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const token = tokenData.access_token;

      // 2. Buscar catalog_id
      const catalogsUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs`;
      
      const catalogsResponse = await axios.get(catalogsUrl, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/json'
        }
      });

      const catalogsData = catalogsResponse.data;
      if (!catalogsData || !Array.isArray(catalogsData) || catalogsData.length === 0) {
        return {
          success: false,
          error: 'Nenhum cat√°logo encontrado'
        };
      }

      const catalogId = catalogsData[0].catalogId || catalogsData[0].id;

      // 3. Buscar todos os itens do cat√°logo
      const itemsUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs/${catalogId}/items`;
      console.log('üåê [API REQUEST] URL:', itemsUrl);

      const itemsResponse = await axios.get(itemsUrl, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/json'
        }
      });

      const allItems = itemsResponse.data || [];
      console.log(`‚úÖ [GET ITEMS] ${allItems.length} itens encontrados na API do iFood`);

      // 4. Filtrar por categoria se especificado
      let filteredItems = allItems;
      if (categoryId) {
        filteredItems = allItems.filter((item: any) => item.categoryId === categoryId);
        console.log(`üìÇ [FILTER] ${filteredItems.length} itens na categoria ${categoryId}`);
      }

      // 5. Sincronizar com banco local
      for (const item of filteredItems) {
        try {
          await this.supabase
            .from('products')
            .upsert({
              item_id: item.id,
              merchant_id: merchantId,
              product_id: item.productId || item.id,
              category: item.categoryName || 'iFood',  // Nome da categoria
              name: item.name || item.description,
              description: item.description,
              price: item.price?.value,
              original_price: item.price?.originalValue,
              is_active: item.status === 'AVAILABLE',
              imagePath: item.imagePath,
              client_id: userId,  // Usando client_id ao inv√©s de user_id
              updated_at: new Date().toISOString()
            });
        } catch (dbError) {
          console.warn(`‚ö†Ô∏è Erro ao sincronizar item ${item.id}:`, dbError);
        }
      }

      return {
        success: true,
        data: filteredItems,
        total_products: filteredItems.length
      };

    } catch (error: any) {
      console.error('‚ùå [GET ITEMS] Erro:', error.response?.data || error.message);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Erro ao buscar itens'
      };
    }
  }

  /**
   * Criar ou atualizar item - VERS√ÉO SIMPLES seguindo EXATAMENTE a documenta√ß√£o
   * PUT /catalog/v2.0/merchants/{merchantId}/items
   */
  async createOrUpdateItem(userId: string, merchantId: string, itemData: any): Promise<ServiceResponse> {
    try {
      console.log(`üçî [CREATE/UPDATE ITEM] Iniciando para merchant: ${merchantId}`);

      // 1. Buscar token
      const { data: tokenData, error: tokenError } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('user_id', userId)  // Corrigido para usar user_id
        .single();

      if (tokenError || !tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const token = tokenData.access_token;

      // 2. Primeiro, buscar o cat√°logo do merchant para pegar o catalogId
      console.log('üîç [CREATE ITEM] Buscando cat√°logo do merchant...');
      const catalogsUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs`;
      
      let catalogId: string;
      try {
        const catalogsResponse = await axios.get(catalogsUrl, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/json'
          }
        });

        const catalogsData = catalogsResponse.data;
        if (!catalogsData || !Array.isArray(catalogsData) || catalogsData.length === 0) {
          return {
            success: false,
            error: 'Nenhum cat√°logo encontrado para este merchant'
          };
        }
        
        catalogId = catalogsData[0].catalogId || catalogsData[0].id;
        console.log(`‚úÖ [CREATE ITEM] Cat√°logo encontrado: ${catalogId}`);
        
      } catch (error: any) {
        console.error('‚ùå [CREATE ITEM] Erro ao buscar cat√°logo:', error.response?.data || error.message);
        return {
          success: false,
          error: 'Erro ao buscar cat√°logo do merchant'
        };
      }

      // 3. Verificar se j√° temos um categoryId v√°lido do iFood
      let realCategoryId: string | undefined = itemData.item?.categoryId;
      
      // Se o categoryId parece ser um UUID v√°lido do iFood, us√°-lo
      const isValidIfoodId = realCategoryId && 
                             realCategoryId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);
      
      if (!isValidIfoodId) {
        // Se n√£o temos um ID v√°lido, buscar categorias do iFood
        console.log('üîç [CREATE ITEM] CategoryId inv√°lido, buscando categorias do iFood...');
        const categoriesUrl = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/catalogs/${catalogId}/categories`;
        
        try {
          const categoriesResponse = await axios.get(categoriesUrl, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Accept': 'application/json'
            }
          });

          const categories = categoriesResponse.data;
          if (categories && Array.isArray(categories) && categories.length > 0) {
            // Usar a primeira categoria dispon√≠vel
            realCategoryId = categories[0].id;
            console.log(`‚úÖ [CREATE ITEM] Usando primeira categoria do iFood: ${realCategoryId}`);
          }
        } catch (error: any) {
          console.error('‚ö†Ô∏è [CREATE ITEM] Erro ao buscar categorias:', error.response?.data || error.message);
        }
      } else {
        console.log(`‚úÖ [CREATE ITEM] Usando categoria fornecida: ${realCategoryId}`);
      }

      // 4. Transformar para o formato correto da API iFood
      // Construir o item com campos obrigat√≥rios m√≠nimos
      const ifoodItem: any = {
        // Campos obrigat√≥rios do iFood
        id: itemData.item?.id || `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        status: itemData.item?.status || 'AVAILABLE',
        price: {
          value: itemData.item?.price?.value || 0
        }
      };
      
      // Adicionar categoryId apenas se tiver um v√°lido
      if (realCategoryId) {
        ifoodItem.categoryId = realCategoryId;
      }
      
      // Adicionar campos opcionais do item apenas se existirem
      if (itemData.item?.price?.originalValue && itemData.item.price.originalValue > 0) {
        ifoodItem.price.originalValue = itemData.item.price.originalValue;
      }
      
      if (itemData.item?.externalCode && itemData.item.externalCode.trim() !== '') {
        ifoodItem.externalCode = itemData.item.externalCode;
      }
      
      // Construir o produto
      const ifoodProduct: any = {
        // Nome √© obrigat√≥rio
        name: itemData.products?.[0]?.name || itemData.item?.name || 'Produto sem nome',
        // ProductId pode ser obrigat√≥rio
        productId: itemData.item?.productId || ifoodItem.id
      };
      
      // Adicionar descri√ß√£o apenas se existir
      if (itemData.products?.[0]?.description && itemData.products[0].description.trim() !== '') {
        ifoodProduct.description = itemData.products[0].description;
      }
      
      // Adicionar imagem apenas se existir
      if (itemData.products?.[0]?.imagePath && itemData.products[0].imagePath.trim() !== '') {
        ifoodProduct.imagePath = itemData.products[0].imagePath;
      }
      
      // Montar o objeto final
      const ifoodItemData = {
        item: ifoodItem,
        products: [ifoodProduct]
      };

      // 5. Validar dados antes de enviar
      console.log('üîç [VALIDATION] Verificando dados antes de enviar...');
      
      if (!ifoodItemData.item || Object.keys(ifoodItemData.item).length === 0) {
        console.error('‚ùå [VALIDATION] Item est√° vazio!');
        return {
          success: false,
          error: 'Dados do item est√£o vazios. Verifique os campos obrigat√≥rios.'
        };
      }
      
      if (!ifoodItemData.products || ifoodItemData.products.length === 0) {
        console.error('‚ùå [VALIDATION] Produtos est√° vazio!');
        return {
          success: false,
          error: 'Dados do produto est√£o vazios. Verifique os campos obrigat√≥rios.'
        };
      }
      
      // 6. Fazer requisi√ß√£o para API do iFood
      const url = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/items`;
      console.log('üåê [API REQUEST] URL:', url);
      console.log('üì§ [API REQUEST] Body:', JSON.stringify([ifoodItemData], null, 2));
      console.log('üìã [API REQUEST] Item fields:', Object.keys(ifoodItemData.item));
      console.log('üìã [API REQUEST] Product fields:', Object.keys(ifoodItemData.products[0]));

      const response = await axios.put(url, [ifoodItemData], {  // Enviar array de FullItemDto
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      });

      console.log('‚úÖ [CREATE/UPDATE ITEM] Item criado/atualizado com sucesso');
      console.log('üì• [API RESPONSE]:', response.data);

      const finalItemId = response.data?.id || `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      // 6. Salvar grupos de op√ß√µes se existirem
      if (itemData.optionGroups && itemData.optionGroups.length > 0) {
        console.log('üíæ [OPTION GROUPS] Salvando grupos de op√ß√µes...');
        
        for (const group of itemData.optionGroups) {
          const groupId = `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Salvar o grupo
          await this.supabase
            .from('ifood_option_groups')
            .upsert({
              group_id: groupId,
              item_id: finalItemId,
              name: group.name,
              status: 'AVAILABLE',
              type: group.type, // RADIO ou CHECKBOX
              min_selection: group.min || 0,
              max_selection: group.max || 1,
              user_id: userId
            });
          
          // Salvar as op√ß√µes do grupo
          if (group.options && group.options.length > 0) {
            for (const option of group.options) {
              const optionId = `option_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              
              await this.supabase
                .from('ifood_item_options')
                .upsert({
                  option_id: optionId,
                  item_id: finalItemId,
                  option_group_id: groupId,
                  name: option.name,
                  status: 'AVAILABLE',
                  price: option.price || 0,
                  user_id: userId
                });
            }
          }
        }
        
        console.log('‚úÖ [OPTION GROUPS] Grupos de op√ß√µes salvos com sucesso');
      }

      // 7. Salvar no banco local
      try {
        await this.supabase
          .from('products')
          .upsert({
            item_id: response.data?.id || ifoodItemData.item.id,
            merchant_id: merchantId,
            product_id: response.data?.productId || ifoodItemData.item.id,
            category: itemData.products?.[0]?.name,  // Nome da categoria
            name: ifoodItemData.item.name,
            description: ifoodItemData.item.description,
            price: ifoodItemData.item.price?.value || 0,
            original_price: ifoodItemData.item.price?.originalValue,
            is_active: ifoodItemData.item.status === 'AVAILABLE',
            imagePath: ifoodItemData.item.imagePath,
            client_id: userId,  // Usando client_id ao inv√©s de user_id
            updated_at: new Date().toISOString()
          });
      } catch (dbError) {
        console.warn('‚ö†Ô∏è Erro ao salvar item localmente:', dbError);
      }

      return {
        success: true,
        data: response.data
      };

    } catch (error: any) {
      console.error('‚ùå [CREATE/UPDATE ITEM] Erro:', error.response?.data || error.message);
      if (error.response?.data?.error?.details) {
        console.error('‚ùå [CREATE/UPDATE ITEM] Detalhes do erro:', JSON.stringify(error.response.data.error.details, null, 2));
      }
      return {
        success: false,
        error: error.response?.data?.error?.message || error.response?.data?.message || error.message || 'Erro ao criar/atualizar item'
      };
    }
  }

  /**
   * Atualizar pre√ßo de item
   * PATCH /catalog/v2.0/merchants/{merchantId}/items/price
   */
  async updateItemPrice(userId: string, merchantId: string, priceData: any): Promise<ServiceResponse> {
    try {
      console.log(`üí∞ [UPDATE PRICE] Atualizando pre√ßo do item: ${priceData.itemId}`);

      // 1. Buscar token
      const { data: tokenData, error: tokenError } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('client_id', userId)  // Using client_id instead of user_id
        .single();

      if (tokenError || !tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const token = tokenData.access_token;

      // 2. Fazer requisi√ß√£o
      const url = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/items/price`;
      
      const response = await axios.patch(url, priceData, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      console.log('‚úÖ [UPDATE PRICE] Pre√ßo atualizado com sucesso');

      // 3. Atualizar banco local
      try {
        await this.supabase
          .from('products')
          .update({
            price: priceData.price?.value,
            original_price: priceData.price?.originalValue,
            updated_at: new Date().toISOString()
          })
          .eq('item_id', priceData.itemId)
          .eq('merchant_id', merchantId);
      } catch (dbError) {
        console.warn('‚ö†Ô∏è Erro ao atualizar pre√ßo localmente:', dbError);
      }

      return {
        success: true,
        data: response.data
      };

    } catch (error: any) {
      console.error('‚ùå [UPDATE PRICE] Erro:', error.response?.data || error.message);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Erro ao atualizar pre√ßo'
      };
    }
  }

  /**
   * Atualizar status de item
   * PATCH /catalog/v2.0/merchants/{merchantId}/items/status
   */
  async updateItemStatus(userId: string, merchantId: string, statusData: any): Promise<ServiceResponse> {
    try {
      console.log(`üîÑ [UPDATE STATUS] Atualizando status do item: ${statusData.itemId}`);

      // 1. Buscar token
      const { data: tokenData, error: tokenError } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('client_id', userId)  // Using client_id instead of user_id
        .single();

      if (tokenError || !tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const token = tokenData.access_token;

      // 2. Fazer requisi√ß√£o
      const url = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/items/status`;
      
      const response = await axios.patch(url, statusData, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      console.log('‚úÖ [UPDATE STATUS] Status atualizado com sucesso');

      // 3. Atualizar banco local
      try {
        await this.supabase
          .from('products')
          .update({
            is_active: statusData.status === 'AVAILABLE',
            updated_at: new Date().toISOString()
          })
          .eq('item_id', statusData.itemId)
          .eq('merchant_id', merchantId);
      } catch (dbError) {
        console.warn('‚ö†Ô∏è Erro ao atualizar status localmente:', dbError);
      }

      return {
        success: true,
        data: response.data
      };

    } catch (error: any) {
      console.error('‚ùå [UPDATE STATUS] Erro:', error.response?.data || error.message);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Erro ao atualizar status'
      };
    }
  }

  /**
   * Atualizar pre√ßo de op√ß√£o
   * PATCH /catalog/v2.0/merchants/{merchantId}/options/price
   */
  async updateOptionPrice(userId: string, merchantId: string, priceData: any): Promise<ServiceResponse> {
    try {
      console.log(`üí∞ [UPDATE OPTION PRICE] Atualizando pre√ßo da op√ß√£o: ${priceData.optionId}`);

      const { data: tokenData } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('user_id', userId)
        .single();

      if (!tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const url = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/options/price`;
      
      const response = await axios.patch(url, priceData, {
        headers: {
          'Authorization': `Bearer ${tokenData.access_token}`,
          'Content-Type': 'application/json'
        }
      });

      return {
        success: true,
        data: response.data
      };

    } catch (error: any) {
      console.error('‚ùå [UPDATE OPTION PRICE] Erro:', error.response?.data || error.message);
      return {
        success: false,
        error: error.response?.data?.message || error.message
      };
    }
  }

  /**
   * Atualizar status de op√ß√£o
   * PATCH /catalog/v2.0/merchants/{merchantId}/options/status
   */
  async updateOptionStatus(userId: string, merchantId: string, statusData: any): Promise<ServiceResponse> {
    try {
      console.log(`üîÑ [UPDATE OPTION STATUS] Atualizando status da op√ß√£o: ${statusData.optionId}`);

      const { data: tokenData } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('user_id', userId)
        .single();

      if (!tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const url = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/options/status`;
      
      const response = await axios.patch(url, statusData, {
        headers: {
          'Authorization': `Bearer ${tokenData.access_token}`,
          'Content-Type': 'application/json'
        }
      });

      return {
        success: true,
        data: response.data
      };

    } catch (error: any) {
      console.error('‚ùå [UPDATE OPTION STATUS] Erro:', error.response?.data || error.message);
      return {
        success: false,
        error: error.response?.data?.message || error.message
      };
    }
  }

  /**
   * Upload de imagem
   * POST /catalog/v2.0/merchants/{merchantId}/image/upload
   */
  async uploadImage(userId: string, merchantId: string, imageData: { image: string }): Promise<ServiceResponse> {
    try {
      console.log(`üì∏ [UPLOAD IMAGE] Fazendo upload de imagem para merchant: ${merchantId}`);

      const { data: tokenData } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('user_id', userId)
        .single();

      if (!tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const url = `${this.IFOOD_API_BASE_URL}/catalog/v2.0/merchants/${merchantId}/image/upload`;
      
      const response = await axios.post(url, imageData, {
        headers: {
          'Authorization': `Bearer ${tokenData.access_token}`,
          'Content-Type': 'application/json'
        }
      });

      console.log('‚úÖ [UPLOAD IMAGE] Imagem enviada com sucesso');

      return {
        success: true,
        data: response.data
      };

    } catch (error: any) {
      console.error('‚ùå [UPLOAD IMAGE] Erro:', error.response?.data || error.message);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Erro ao fazer upload da imagem'
      };
    }
  }

  /**
   * Ingest√£o de itens em bulk
   * POST /item/v1.0/ingestion/{merchantId}?reset=false
   */
  async bulkItemIngestion(userId: string, merchantId: string, items: any[], reset: boolean = false): Promise<ServiceResponse> {
    try {
      console.log(`üì¶ [BULK INGESTION] Enviando ${items.length} itens para merchant: ${merchantId}`);

      const { data: tokenData } = await this.supabase
        .from('ifood_tokens')
        .select('access_token')
        .eq('user_id', userId)
        .single();

      if (!tokenData?.access_token) {
        return {
          success: false,
          error: 'Token de acesso n√£o encontrado'
        };
      }

      const url = `${this.IFOOD_API_BASE_URL}/item/v1.0/ingestion/${merchantId}?reset=${reset}`;
      
      const response = await axios.post(url, items, {
        headers: {
          'Authorization': `Bearer ${tokenData.access_token}`,
          'Content-Type': 'application/json'
        }
      });

      console.log(`‚úÖ [BULK INGESTION] ${items.length} itens enviados com sucesso`);

      // Salvar itens localmente
      try {
        const itemsToInsert = items.map(item => ({
          item_id: item.barcode || item.plu,
          merchant_id: merchantId,
          name: item.name,
          description: item.details?.description,
          price: item.prices?.price,
          original_price: item.prices?.promotionPrice,
          status: item.active ? 'AVAILABLE' : 'UNAVAILABLE',
          image_path: item.details?.imageUrl,
          user_id: userId,
          created_at: new Date().toISOString()
        }));

        await this.supabase
          .from('ifood_items')
          .upsert(itemsToInsert);

        console.log('üíæ Itens salvos localmente');
      } catch (dbError) {
        console.warn('‚ö†Ô∏è Erro ao salvar itens localmente:', dbError);
      }

      return {
        success: true,
        data: {
          itemsProcessed: items.length,
          response: response.data
        }
      };

    } catch (error: any) {
      console.error('‚ùå [BULK INGESTION] Erro:', error.response?.data || error.message);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Erro na ingest√£o em bulk'
      };
    }
  }

}